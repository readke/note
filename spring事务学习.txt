1、事务的传播特性
	Propagation.REQUIRED 表示必须在事务中执行（默认）
		原来有事务就加入到事务中，如果没有则新建一个事务
	Propagation.NOT_SUPPORTED 容器不为这个方法开启事务
	Propagation.REQUIRED_NEW 表示必须新建一个事务
		不管是否存在事务，都创建一个新的事务，原来存在的事务挂起，新的事务执行完毕后
		继续执行原来的事务
	Propagation.MANDATORY
		必须在一个已经存在的事务中执行，否则抛出异常
	Propagation.NEVER
		不能在事务中执行，否则抛出异常
	Propagation.SUPPORTS
		跟随调用者，调用者在事务中执行，就在事务中执行，否则就不在事务中执行
		
2、事务的隔离级别
	READ_UNCOMMITTED 读取未提交数据（脏读，不可重复读） 基本不使用
	READ_COMMITTED 读取已提交数据（会出现不可重复读，幻读）
		对当前数据不加锁：其他事务可以修改当前事务操作的数据，导致当前事务操作的
		数据发生变化
	REPEATABLE_READ 可重复读（会出现幻读）
		对当前数据加锁：其他事务不可以修改当前事务操作的数据，但是可以写入其他数
		据，当前事务会读到其他事务写入的数据，即幻读
	SERIALIZABLE	串行化
		事务只能序列化执行，一个事务执行完毕后才能执行下一个事务
	
	
解释： 
	脏读：一个事务读取到另一个事务未提交的更新数据
	不可重复读：在同一个事务中，多次读取的数据返回结果不同，后续读取可以读取到另
				一事务已提交的更新数据
	幻读：一个事务读到另一个事务已提交的数据
	
