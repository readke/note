前置知识：
	1、queue接口(队列)
		特点：先进先出，从队列的头部删除元素，从队列的尾部添加元素
		接口定义：
		boolean add(E e);  在尾部添加元素  如果队列满了的话，抛出IllegalStateException异常
		boolean offer(E e);	在尾部添加元素，如果队列满了的话，反回false
		E remove(); 返回头部元素，并删除，如果队列为空，抛出NoSuchElementException异常
		E poll();	返回头部元素，并删除，如果队列为空，返回null
		E element(); 仅返回头部元素，如果队列为空，抛出NoSuchElementException异常
		E peek();	仅返回头部元素，如果队列为空，返回null
	2、deque接口(栈)
		特点：先进后出，从队列的顶端添加元素，从队列的顶端删除元素
		接口定义：
		void push(E e);  入栈，从顶部添加元素，如果栈满了，抛出IllegalStateException异常
		E pop();		出栈，返回顶部的元素，并从栈中删除，如果栈为空，抛出NoSuchElementException异常
		E peek();		查看栈顶元素。如果栈为空，返回null
		
	3、deque接口(双端队列)
		特点：两端都可以添加和删除元素
		接口定义：
		void addFirst(E e);	   在头部添加元素，如果队列满了的话，抛出IllegalStateException异常
		void addLast(E e);		在尾部添加元素，如果队列满了的话，抛出IllegalStateException异常
		E getFirst();	取出头部元素，如果队列为空的话，抛出NoSuchElementException异常
		E getLast(E e);	取出尾部元素，如果队列为空的话，抛出NoSuchElementException异常
		boolean offerFirst(E e);	在头部添加元素，如果队列满了的话，返回false	
		boolean offerLast(E e);		在尾部添加元素，如果队列满了的话，返回false
		E peekFirst();	返回头部元素，如果队列为空，返回null
		E peekLast();	返回尾部元素，如果队列为空，返回null
		E pollFirst();	返回头部元素，并删除，如果队列为空，返回null
		E pollLast();	支架尾部元素，并删除，如果队列为空，返回null
		E removeFirst(); 返回头部元素，并删除，如果队列为空，抛出NoSuchElementException异常
		E removeLast();		返回尾部元素，并删除，如果队列为空，抛出NoSuchElementException异常
1、linkedList 特点
	说明：插入和删除数据效率很高，访问数据的效率很低
	实现原理：  
		内部使用双向链表来实现的，为了表示一链接关系，需要一个节点为的概念。节点
		包括实际的元素、指向前一个节点为的链接、指向后一个节点的链接。节点是一个
		内部类。
		private static class Node<E>{
			E item;
			Node<E> prev;
			Node<E> next;
			
			Node(Node<E> prev,E element,Node<E> next){
				this.item = element;
				this.prev = prev;
				this.next = next;
			}
		}
	
	linkedList内部组成就是如下三个实例变量：
		transient int size = 0;		size 表示链表的长度
		transient Node<E> first;	first 指向链表的头节点；
		transient Node<E> last;		last 指向链表的尾节点；
		
2、linkedList 操作头尾节点的核心方法
	1) void linkFirst(E element)
	2) void linkLast(E element)
	3) Node<E> node(int)
	4) void linkBefore(E element)
	5) unlink(Node<E> node)
	6) unlinkFirst(Node<E> node)
	7) unlinkLast(Node<E> node)
	
	linkFirst(E element) 
	说明：
		向尾部添加一个节点
	实现原理：
		1) 获取链表当前尾节点对象；
		2) 创建一个新节点,新节点的前一个节点为当前尾节点,新节点的后一个节点为null；
		3) 尾节点指向新节点；
		4) 判断前尾节点对象是否为空，如果为空(链表为空)，首节点指向新节点；如果不
		   为空，前尾节点对象的下一个节点指向新的尾节点
		5) 链表长度+1，改变次数+1
	
	